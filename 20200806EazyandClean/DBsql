SELECT * FROM emp;
--     EMPNO ENAME                JOB                       MGR HIREDATE        SAL       COMM     DEPTNO
------------ -------------------- ------------------ ---------- -------- ---------- ---------- ----------
--      7369 smith                clerk                    7902 80/12/17        800                    20
--      7499 allen                salesman                 7698 81/02/20       1600  0,000,300         30
--      7521 ward                 salesman                 7698 81/02/22       1250  0,000,500         30
--      7566 jones                manager                  7839 81/04/02       2975                    20
--      7654 martin               salesman                 7698 81/09/28       1250  0,001,400         30
--      7698 blake                manager                  7839 81/05/01       2850                    30
--      7782 clark                manager                  7839 81/06/09       2450                    10
--      7788 scott                analyst                  7566 87/04/19       3000                    20
--      7839 king                 president                     81/11/17       5000                    10
--      7844 turner               salesman                 7698 81/09/08       1500  0,000,000         30
--      7876 adams                clerk                    7788 87/05/23       1100                    20
--      7900 james                clerk                    7698 81/12/03        950                    30
--      7902 ford                 analyst                  7566 81/12/03       3000                    20
--      7934 miller               clerk                    7782 82/01/23       1300                    10

insert into emp values (7369,'smith','clerk',7902,to_date('80/12/17','yy/mm/dd'),800,NULL,20);
insert into emp values (7499,'allen','salesman',7698,to_date('81/02/20','yy/mm/dd'),1600,300,30);
insert into emp values (7521,'ward','salesman',7698,to_date('81/02/22','yy/mm/dd'),1250,500,30);
insert into emp values (7566,'jones','manager',7839,to_date('81/04/02','yy/mm/dd'),2975,NULL,20);
insert into emp values (7654,'martin','salesman',7698,to_date('81/09/28','yy/mm/dd'),1250,1400,30);
insert into emp values (7698,'blake','manager',7839,to_date('81/05/01','yy/mm/dd'),2850,NULL,30);
insert into emp values (7782,'clark','manager',7839,to_date('81/06/09','yy/mm/dd'),2450,NULL,10);
insert into emp values (7788,'scott','analyst',7566,to_date('87/04/19','yy/mm/dd'),2000,NULL,20);
insert into emp values (7839,'king','president',NULL,to_date('81/11/17','yy/mm/dd'),5000,NULL,10);
insert into emp values (7844,'turner','salesman',7698,to_date('81/09/08','yy/mm/dd'),1500,0,30);
insert into emp values (7876,'adams','clerk',7788,to_date('87/05/23','yy/mm/dd'),1100,NULL,20);
insert into emp values (7900,'james','clerk',7698,to_date('81/12/03','yy/mm/dd'),950,NULL,30);
insert into emp values (7902,'ford','analyst',7566,to_date('81/12/03','yy/mm/dd'),3000,NULL,20);
insert into emp values (7934,'miller','clerk',7782,to_date('82/01/23','yy/mm/dd'),1300,NULL,10);

SELECT ENAME, SAL *12+comm as "a n n s a l" FROM emp;

SELECT ename, 'is a', Sal * 12 +comm from emp;

SELECT ename || ' is a ' || Job from emp;

select distinct deptno  from emp;

select * from emp where deptno = 30;

select * from emp where deptno = 30 and job = 'salesman';

select * from emp where deptno = 30 or job = 'clerk';

select * from emp where sal * 12 >= 36000;

select * from emp where sal * 12 = 36000;

select * from emp where ename <= 'forz';

select * from emp where deptno != 30;

select * from emp where deptno ^= 30;

select * from emp where deptno <> 30;

select * from emp where job in ('salesman', 'clerk');

select * from emp where sal >= 2000 and sal <= 3000;

select * from emp where sal between 2000 and 3000;


select * from emp where ename like 's%';

select * from emp where ename like '_l%';

select * from emp where comm is NULL;

select * from emp where comm is not NULL;


select empno, ename, sal, deptno from emp where deptno = 10 union 
Select  empno, ename, sal, deptno from emp where deptno = 20;

select empno, ename, sal, deptno from emp where deptno = 10 union 
Select  empno, ename, sal, deptno from emp where deptno = 20;
-- 5-1
SELECT * from emp where ename like '%s';
-- 5-2
select empno, ename, job, sal, deptno from emp where deptno = 30 and job = 'salesman';
-- 5-3.1
select empno, ename, job, sal, deptno from emp where deptno in (30,20) and sal > 2000;

select empno, ename, job, sal, deptno from emp where (deptno = 30 or deptno = 20) and sal > 2000;
-- 5-3.2
select empno, ename, job, sal, deptno from emp where deptno = 30 and sal > 2000 union 
select empno, ename, job, sal, deptno from emp where deptno = 20 and sal > 2000 ;
--distinct<<  중복 제거
--union<<(합집합)비슷한거임(all붙이면 중복 상관없이 출력)
--intersect<(교집합)
--minus- 차집합

-- 5-4
select * from emp minus select * from emp where sal >= 2000 and sal <=3000;

-- 5-5
select ename, empno, sal, deptno from emp where ename like '%e%' and deptno = 30 minus
select ename, empno, sal, deptno from emp where sal between 1000 and 2000;

-- 5-6
select * from emp where comm is null and job in ('clerk', 'manager') minus 
select * from emp where ename like '_l%';

--commit;
--
--	    System.out.print( "아이디는>>" +  rs.getString( "id" ) ); 
--				System.out.print( ", 이름은>>" +  rs.getString( "name" ) );
--				System.out.print( ", 키는>>" +  rs.getInt( "height" ) );
--				System.out.print( ", 체중은>>" +  rs.getInt( "weight" ) );
--				System.out.print( ", 나이는>>" +  rs.getInt( "age" ) );
--                String query = "INSERT INTO Member VALUES ( '0003','차범근' , 185, 85 , 23 )";
create table Member(
    id VARCHAR2(10) primary key,
    name VARCHAR2(20) not null,
    height NUMBER(5) not null,
    weight NUMBER(5)not null,
    age NUMBER(5) not null
);
drop table Member;
select * from Member;

insert Into member(id, name, height, weight, age)
            values('0001', '홍길동', 178, 68, 30);
Insert Into member(id, name, height, weight, age)
            values('0002', '이순신', 170, 56, 24);
Insert Into member(id, name, height, weight, age)
            values('0003', '박찬호', 189, 89, 32);           
COMMIT;

create Table Rent_Car(
    carNumber VARCHAR2(10) primary key,
    carName VARCHAR2(20) not null,
    carColor VARCHAR2(20) not null,
    carSize NUMBER(5) not null,
    carMaker VARCHAR2(20) not null
);

INSERT INTO Rent_Car(carNumber,carName,carColor,carSize,carMaker) VALUES ('12나35','가나다','검정',4000,'대우');
INSERT INTO Rent_Car(carNumber,carName,carColor,carSize,carMaker) VALUES ('12다35','가나다','검정',4000,'대우');
INSERT INTO Rent_Car(carNumber,carName,carColor,carSize,carMaker) VALUES ('12라35','가나다','검정',4000,'대우');
INSERT INTO Rent_Car(carNumber,carName,carColor,carSize,carMaker) VALUES ('13나35','가나다','검정',4000,'대우');
INSERT INTO Rent_Car(carNumber,carName,carColor,carSize,carMaker) VALUES ('14다35','가나다','검정',4000,'대우');
INSERT INTO Rent_Car(carNumber,carName,carColor,carSize,carMaker) VALUES ('15라35','가나다','검정',4000,'대우');
INSERT INTO Rent_Car(carNumber,carName,carColor,carSize,carMaker) VALUES ('16나35','가나다','검정',4000,'대우');
INSERT INTO Rent_Car(carNumber,carName,carColor,carSize,carMaker) VALUES ('17다35','가나다','검정',4000,'대우');
INSERT INTO Rent_Car(carNumber,carName,carColor,carSize,carMaker) VALUES ('18라35','가나다','검정',4000,'대우');
INSERT INTO Rent_Car(carNumber,carName,carColor,carSize,carMaker) VALUES ('12나36','가나다','검정',4000,'대우');
INSERT INTO Rent_Car(carNumber,carName,carColor,carSize,carMaker) VALUES ('12다36','가나다','검정',4000,'대우');
INSERT INTO Rent_Car(carNumber,carName,carColor,carSize,carMaker) VALUES ('12라36','가나다','검정',4000,'대우');
INSERT INTO Rent_Car(carNumber,carName,carColor,carSize,carMaker) VALUES ('13나36','가나다','검정',4000,'대우');
INSERT INTO Rent_Car(carNumber,carName,carColor,carSize,carMaker) VALUES ('14다36','가나다','검정',4000,'대우');
INSERT INTO Rent_Car(carNumber,carName,carColor,carSize,carMaker) VALUES ('15라36','가나다','검정',4000,'대우');
INSERT INTO Rent_Car(carNumber,carName,carColor,carSize,carMaker) VALUES ('16나36','가나다','검정',4000,'대우');
INSERT INTO Rent_Car(carNumber,carName,carColor,carSize,carMaker) VALUES ('17다36','가나다','검정',4000,'대우');
INSERT INTO Rent_Car(carNumber,carName,carColor,carSize,carMaker) VALUES ('18라36','가나다','검정',4000,'대우');
INSERT INTO Rent_Car(carNumber,carName,carColor,carSize,carMaker) VALUES ('12나37','가나다','검정',4000,'대우');
INSERT INTO Rent_Car(carNumber,carName,carColor,carSize,carMaker) VALUES ('12다37','가나다','검정',4000,'대우');
INSERT INTO Rent_Car(carNumber,carName,carColor,carSize,carMaker) VALUES ('12라37','가나다','검정',4000,'대우');
INSERT INTO Rent_Car(carNumber,carName,carColor,carSize,carMaker) VALUES ('13나37','가나다','검정',4000,'대우');
INSERT INTO Rent_Car(carNumber,carName,carColor,carSize,carMaker) VALUES ('14다37','가나다','검정',4000,'대우');
INSERT INTO Rent_Car(carNumber,carName,carColor,carSize,carMaker) VALUES ('15라37','가나다','검정',4000,'대우');
INSERT INTO Rent_Car(carNumber,carName,carColor,carSize,carMaker) VALUES ('16나37','가나다','검정',4000,'대우');
INSERT INTO Rent_Car(carNumber,carName,carColor,carSize,carMaker) VALUES ('17다37','가나다','검정',4000,'대우');
INSERT INTO Rent_Car(carNumber,carName,carColor,carSize,carMaker) VALUES ('18라37','가나다','검정',4000,'대우');
INSERT INTO Rent_Car(carNumber,carName,carColor,carSize,carMaker) VALUES ('12나38','가나다','검정',4000,'대우');
INSERT INTO Rent_Car(carNumber,carName,carColor,carSize,carMaker) VALUES ('12다38','가나다','검정',4000,'대우');
INSERT INTO Rent_Car(carNumber,carName,carColor,carSize,carMaker) VALUES ('12라38','가나다','검정',4000,'대우');
INSERT INTO Rent_Car(carNumber,carName,carColor,carSize,carMaker) VALUES ('13나38','가나다','검정',4000,'대우');
INSERT INTO Rent_Car(carNumber,carName,carColor,carSize,carMaker) VALUES ('14다38','가나다','검정',4000,'대우');
INSERT INTO Rent_Car(carNumber,carName,carColor,carSize,carMaker) VALUES ('15라38','가나다','검정',4000,'대우');
INSERT INTO Rent_Car(carNumber,carName,carColor,carSize,carMaker) VALUES ('16나38','가나다','검정',4000,'대우');
INSERT INTO Rent_Car(carNumber,carName,carColor,carSize,carMaker) VALUES ('17다38','가나다','검정',4000,'대우');
INSERT INTO Rent_Car(carNumber,carName,carColor,carSize,carMaker) VALUES ('18라38','가나다','검정',4000,'대우');

select count(*) from Rent_Car;


UPDATE Rent_car SET carName = carName, carColor = carcolor, carSize = carSize, carMaker = carMaker WHERE carNumber = carnumber;

delete from rent_car where carnumber = '1';

select * from Rent_Car;

create Table Rent_Member(
    id VARCHAR2(10) primary key,
    password VARCHAR2(20) not null,
    name VARCHAR2(20) not null,
    address VARCHAR2(40) not null,
    phone VARCHAR2(20) not null
);
drop table Rent_Member;
rollback;
commit;
delete from Rent_Member;
select * from Rent_Member;



--INSERT INTO Rent_Member(id,password,name,address,phone) VALUES ('memID','memPass', 'memName'," +
--													memAdd+",'" +
--													memPhone+"')";

create Table Rent_Res(
    resNum VARCHAR(20) primary key not null,
    resCarNumber VARCHAR2(10) references Rent_Car(carNumber) not null,
    memberID VARCHAR2(10) references Rent_Member(id) not null, 
    resDate date not null,
    useBeginDate date not null,
    returnDate date not null,
    charge NUMBER(10) 
  
--    CONSTRAINT rent_member id fk 
--    FOREIGN KEY (memberID)
--    REFERENCES Rent_member(id),
  
--    CONSTRAINT Rent_car carNumber fk 
--    FOREIGN KEY (resCarNumber)
--    REFERENCES Rent_car(carNumber),
);

delete from Rent_Res;
select * from Rent_Res;
drop table rent_res;

select * from Rent_Res;
select * from Rent_Car where resCarNumber = '1';

INSERT INTO Rent_Res(resNum, resCarNumber, memberID, resDate, useBeginDate, returnDate, charge)
VALUES ('001','11가 34','0001', TO_DATE('2020-05-25', 'yyyy-mm-dd'),
                                        TO_DATE('2020-05-28', 'yyyy-mm-dd'),
                                        TO_DATE('2020-05-30', 'yyyy-mm-dd'),150000);
                                        
INSERT INTO Rent_Res(resNum, resCarNumber, memberID, resDate, useBeginDate, returnDate, charge)                                        
VALUES ('002','1111','0002', TO_DATE('2020-06-05', 'yyyy-mm-dd'),
                                        TO_DATE('2020-06-19', 'yyyy-mm-dd'),
                                        TO_DATE('2020-06-20', 'yyyy-mm-dd'),100000);
INSERT INTO Rent_Res(resNum, resCarNumber, memberID, resDate, useBeginDate, returnDate, charge)                                        
VALUES ('003','11가 34','0001', TO_DATE('2020-05-24', 'yyyy-mm-dd'),
                                        TO_DATE('2020-05-25', 'yyyy-mm-dd'),
                                        TO_DATE('2020-05-30', 'yyyy-mm-dd'),300000);                                        



















select ename, deptno,
            decode(deptno, 20, 'research',
                        30, 'sales',
                        40, 'operation',
                        'default') as dname
from emp order by deptno;
            
--CASE 표현식  WHEN 조건1 THEN 결과1 
--                     WHEN 조건2 THEN 결과2 
--                     WHEN 조건3 THEN 결과3 
--                     ELSE 결과n 

select ename, deptno, case when deptno = 10 then 'ACCOUNTING'
                           when deptno = 20 then 'RESEARCH'
                           when deptno = 30 then 'SALES'
                           When deptno = 40 then 'OPERATIONS'
                           ELSE 'DEFAULT'
                      END AS DNAME
                      from emp
                      order by deptno;
                      
select deptno, job, count(*), sum(sal)
from emp
group by deptno, job
order by deptno, job;

select sum(sal) as "급여총액", 
       trunc(avg(sal),3) as "급여평균",
       max(sal) as "최대급여",
       min(sal) as "최소급여"
from emp;

select ename, sal, sal+300 from emp;
select ename, sal, sal * 12 + 100 from emp order by sal desc;
select ename, sal from emp where sal > 2000 order by sal desc;
select ename, deptno from emp where empno = 7788;
select ename, sal from emp where sal not between 3000 and 2000;
select ename, job, hiredate from emp where hiredate between to_date('1981/2/20','yyyy/mm/dd') and to_date('1981/5/1', 'yyyy/mm/dd');
select ename, job, hiredate from emp where hiredate between '1981/2/20' and '1981/5/1';
-- between은 무조건 앞선 날짜 혹은 작은 숫자가 앞에 나와야 한다. 늦은 날짜 혹은 큰 숫자가 앞에오고 앞선날짜가 뒤에오면 찾지를 못한다.
select ename, job, hiredate from emp where hiredate between '1981/5/1' and '1981/2/20';
select ename, deptno from emp where deptno between 20 and 30 order by deptno desc;
select ename, sal, deptno 
from emp 
where sal between 2000 and 3000 
and deptno between 20 and 30
order by ename asc;

select ename, sal, deptno 
from emp 
where sal between 2000 and 3000 
and deptno in (20,30)
order by ename asc;

select ename, hiredate from emp where hiredate like '81%';
select ename, job from emp where mgr is null;
select ename, sal, comm from emp where comm is not null order by sal, comm desc;
select ename, sal, comm from emp where comm is not null order by sal, comm;
select ename from emp where ename like '__r%';
select ename from emp where ename like '%a%e%';
select ename 
from emp 
where ename like '%a%' 
and ename like '%e%';

select ename, job, sal 
from emp 
where job in('clerk', 'salesman') 
and sal not in (1600,950,1300);

select ename, sal, comm from emp where comm >= 500;

-- 4장 
select substr(to_char(hiredate), 1,2) as "년도", substr(to_char(hiredate), 4,2) as "달" from emp;
select empno, ename, job, mgr, hiredate, sal, comm 
from emp 
where substr(hiredate,4,2) like '04';

select empno, ename, job, mgr, hiredate, sal, comm 
from emp 
where substr(hiredate,4,2) = '04';

select * from emp
where mod(empno,2) = 0;

select hiredate, to_char(hiredate, 'yy/mm,dd day') 
from emp;

select hiredate, to_char(hiredate, 'yy/mm,dd dy') 
from emp;

select trunc(sysdate - to_date('2020/01/01', 'yyyy/mm/dd')) from dual;

select sysdate - to_date('2020/01/01', 'yyyy/mm/dd') from dual;
select empno, ename, NVL2(mgr,mgr,0) from emp;

select empno, ename, job, sal, DECODE (job,'analyst', sal + 200,
                  'salesman', sal + 180,
                  'manager', sal + 150,
                  'clerk', sal + 100,
                  sal) as Update_sal  from emp; 
                  
                  
select * from dept, emp;

select * from dept, emp where emp.deptno = dept.deptno;
-- 레코드가 더 많은쪽에 기준이 되어 출력된다.
select ename as "뭠마" from dept, emp where dept.deptno =  emp.deptno and emp.empno = 7788;

select e.empno, e.ename, d.dname, deptno
from emp e natural join dept d
where e.empno=7788;

select e.empno, e.ename, d.dname, e.deptno
from emp e, dept d
where e.empno=7788;

select e.empno, e.ename, d.dname, deptno
from emp e join dept d
using(deptno)
where e.empno=7788;
drop table salgrade;
create table salgrade (
    grade number(5) primary key,
    losal number(10),
    hisal number(10)
);

insert into salgrade values (1,700,1200);
insert into salgrade values (2,1201,1400);
insert into salgrade values (3,1401,2000);
insert into salgrade values (4,2001,3000);
insert into salgrade values (5,3001,9999);

commit;

select ename, sal, grade, losal, hisal
from emp, salgrade
where sal between losal and hisal;

select ename, dname, sal, grade, losal, hisal
from emp, salgrade ,dept
where emp.deptno = dept.deptno 
and sal between losal and hisal;


select employees.ename as "사원 이름", manager.mgr as "관리자 이름"
from emp employees, emp manager
where employees.mgr = manager.empno;

select employees.ename || '의 직속상관은 ' || manager.ename
from emp employees join emp manager 
on employees.mgr = manager.empno;

select employees.ename || '의 직속상관은 ' || manager.ename
from emp employees full outer join emp manager 
on employees.mgr = manager.empno;

select employees.ename || '의 직속상관은 ' || manager.ename
from emp employees left outer join emp manager 
on employees.mgr = manager.empno;

select employees.ename || '의 직속상관은 ' || manager.ename
from emp employees right outer join emp manager 
on employees.mgr = manager.empno;

select employees.ename || '의 직속상관은 ' || manager.ename
from emp employees join emp manager 
on employees.mgr = manager.empno(+);

select employees.ename || '의 직속상관은 ' || manager.ename
from emp employees join emp manager 
on employees.mgr(+) = manager.empno;
-- (+)는 null 값이 있는 것도 포함한다는 것이다.

select employees.ename || '의 직속상관은 ' || manager.ename
from emp employees join emp manager 
on employees.mgr(+) = manager.empno(+);


select e.ename, d.deptno, d.dname 
from dept d join emp e
on e.deptno = d.deptno and e.ename = 'scott';

select e.ename, d.deptno, d.dname 
from dept d join emp e
on e.deptno = d.deptno
where e.ename = 'scott';

select e.ename, d.dname, loc 
from dept d join emp e
on e.deptno = d.deptno order by dname;

select deptno, job, loc 
from emp join dept 
using (deptno) 
where deptno = 10 ;

select ename, dname, loc
from emp natural join dept
where comm > 0;

select e.ename, d.dname 
from emp e,dept d
where e.deptno = d.deptno and e.ename like '%a%';

select e.ename, d.dname 
from emp e join dept d
on e.deptno = d.deptno 
where e.ename like '%a%';

select ename, job, deptno, dname
from emp e NATURAL join dept d
where d.loc = 'new york';

select e.ename employee, e.mgr emp#, m.empno manager, m.ename mgr#
from emp e join emp m 
on e.mgr = m.empno;

select e.ename employee, e.mgr emp#, m.empno manager, m.ename mgr#
from emp e left outer join emp m 
on e.mgr = m.empno;

select e.ename 이름, d.deptno 부서번호 , d.ename 동료
from emp e join emp d
on e.deptno = d.deptno and d.deptno = (select deptno from emp where ename = 'scott') and e.ename = 'scott' and d.ename != 'scott';

select e.ename 이름, d.deptno 부서번호 , d.ename 동료
from emp e , emp d
where e.deptno = d.deptno and d.deptno = (select deptno from emp where ename = 'scott') and e.ename = 'scott' and d.ename != 'scott';

select d.ename, d.hiredate from emp e, emp d where d.hiredate > e.hiredate and e.ename = 'ward' order by d.hiredate;

select employee.ename, employee.hiredate, manager.ename, manager.hiredate 
from emp employee, emp manager
where manager.hiredate > employee.hiredate 
and employee.mgr = manager.empno 
order by to_date(substr(manager.hiredate,4,2), 'mm');

select ename, deptno
from emp 
where deptno = (select deptno 
                from emp 
                where ename = 'scott');


select empno, ename 
from emp 
where sal in (select min(sal) 
              from emp
              group by deptno);
              
select empno, ename, job, sal
from emp 
where sal < any (select sal  -- < any (서브쿼리)  이것은 서브쿼리의 결과중 최대값보다 작은것이다. 
                 from emp    -- > any (서브쿼리)  이것은 서브쿼리의 결과중 최소값보다 큰것이다. 
                 where job = 'salesman') 
and job not in 'salesman'; -- <>는 not in과 같다.
and job <> 'salesman';    

select sal
from emp
where job = 'salesman';

select empno, ename, job, sal 
from emp 
where sal  < all (select sal
                  from emp
                  where job = 'salesman')
and job <> 'salesman';

-- 7-1
select ename , job 
from emp
where job = (select job 
             from emp
             where empno = 7788);
             
-- 7-2
select ename , job 
from emp
where sal > (select sal 
             from emp
             where empno = 7499);
             
-- 7-3             
select ename, job, sal 
from emp
where sal = (select min(sal)               
             from emp);
             
-- 7-4
select job, round(avg(sal),1) 
from emp 
group by job 
having round(avg(sal),1) = (select min(round(avg(sal),1))
                            from emp
                            group by job);

select 56.519 - 56.502 from dual;
        
create table dept20
as 
select empno, ename, sal * 12 annual
from emp
where deptno = 20;

-- 테이블 구조만 복사하는 방법은 테이블의 모든 데이터를 조회를 하되 단 where절에 거짓이 되게 하면 항상 거짓이라 데이터는 복사하지 않고 구조만 복사가 됩니다.
create table dept_third
as 
select deptno, dname
from dept
where 0 = 1;

alter table dept20 add (birth date);

ALTER TABLE dept20
           MODIFY ename varchar2(30);

ALTER TABLE dept20 DROP COLUMN  ename;


ALTER TABLE dept20 SET UNUSED(eMPno);
ALTER TABLE dept20 DROP UNUSED COLUMNS;
SELECT * FROM DEPT20;

RENAME DEPT20 TO EMP20;

DROP TABLE EMP20;

SELECT TABLE_NAME FROM USER_TABLES;

SELECT OWNER, TABLE_NAME FROM DBA_TABLES;

SELECT TABLE_NAME FROM ALL_TABLES;

-- 테이블 만들기 여러가지 자료형으로 

create table emp_insert 
as select * from emp where 1=0;

insert into emp_insert
values (1, 'LEEJM', 'STUDENT', null, sysdate, 2700,230,10);


insert into emp_insert
values (1, 'LEEJH', 'STUDENT', null, sysdate-1, 1500,null,10);

drop table emp_copy;

create table emp_copy
as select * from emp;
                  
update emp_copy set deptno = 10 
where empno = 7788;

update emp_copy set (job, sal) = (select job, sal from emp_copy where empno = 7499) where empno = 7788;


CREATE TABLE dept_second(
dno number(2) constraint pk_dept_second primary key,
dname  varchar2(14),
loc varchar2(13)
);
drop table dept_third;
CREATE TABLE dept_third(
dno number(2),
dname  varchar2(14),
loc varchar2(13),
constraint pk_dept_third primary key(dno)
);

select * from  dept_third;

-- 유저가 만든 제약조건을 보여준다.
SELECT * 
FROM USER_CONS_COLUMNS; 

-- 어떤 테이블에 어떤 제약 조건이 설정되어 있는지 종류와 제약 조건 이름을 알 수 있습니다.
-- USER_CONSTRAINTS 테이블의 내용을 살펴봅시다
SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME 
FROM USER_CONSTRAINTS;

drop table emp_second;

CREATE TABLE emp_second(
empno        NUMBER(4) constraint emp_second_eno_pk primary key,
ename      VARCHAR2(10),
Job        VARCHAR2(9),
deptno        number(2)
);

CREATE TABLE emp_second(
empno     NUMBER(4) constraint emp_second_empno_pk primary key,
ename   VARCHAR2(10),
sal number(7,2) constraint emp_second_salary_min CHECK (sal > 0 ));

create table emp_second(
empno   number(4) constraint emp_second_empno_pk primary key,
ename varchar2(10),
sal number(7,2) constraint emp_second_sal_min check (sal > 0));


CREATE TABLE customer(
 id      VARCHAR2(20) constraint customer_id_uk unique,  -- unique 제약조건의 이름을 customer_id_uk로 하는 것이다.
 pwd   VARCHAR2(20) constraint customer_pwd_nn NOT NULL, -- NOT NULL 제약조건의 이름을 customer_pwd_nn로 하는 것이다.
 name VARCHAR2(30) constraint customer_name_nn NOT NULL, -- NOT NULL 제약조건의 이름을 customer_name_nn로 하는 것이다
 phone     VARCHAR2(30) ,
 address  VARCHAR2(100)) ;

    
SELECT VIEW_NAME, TEXT
FROM USER_VIEWS;  -- USER_VIEWS 데이터 사전 살피기
--뷰는 데이터를 저장하고 있지 않은 가상 테이블이므로 실체가 없습니다. 
--뷰가 테이블처럼 사용될 수 있는 이유는 뷰를 정의할 때 CREATE VIEW 명령어 다음의 AS 절에 기술한 쿼리 문장 자체를 저장하고 있다가 이를 실행하기 때문입니다. 

create or replace view v_emp_job2
as 
select empno, ename, deptno, job
from emp_second
where job like 'manager';

drop view v_emp_job2;

create table emp_second as select * from emp;    

create view v_emp_job(사원, 사원이름, 부서번호, 담당업무)
as select empno, ename, deptno, job
from emp_second
where job like 'salesman';

select * from v_emp_job;

create view v_emp_job2
as 
select empno, ename, deptno, job
from emp_second
where job like 'salesman';

select * from v_emp_job2;


create table dept_second as select * from dept;
drop table dept_second;
select * from dept_second;

create view v_emp_complex
as 
select * 
from emp_second natural join dept_second;

create view v_emp_sample
as 
select empno, ename, job, mgr, deptno
from emp_second;

create view v_emp_complex2
as 
select e.empno, e.ename, e.sal, deptno, d.dname, d.loc
from emp_second e natural join dept_second d;


select (120-88.9)/120*100 from dual;
select (73-56.5)/73*100 from dual;


create view v_emp_job(사번,사원이름,부서번호,담당업무)
as 
select empno, ename, deptno, job
from emp_second
where job like 'salesman';

drop view v_emp_job;

select * from v_emp_job;

create view v_emp_complex
as 
select * from emp_second natural join dept_second;

select * from v_emp_complex;
select * from v_emp_sample;
select * from v_emp_complex2;


select view_name, text
from user_views;

insert into v_emp_job
values(8000, '윤정화', 30, 'salesman');

select * from v_emp_job;

select * from emp_second;


create view v_emp_salary
as 
select deptno, sum(sal) as "sal_num", avg(sal) as "sal_avg"
from emp_second
group by deptno;

-- 데이터베이스내에 뷰를 확인하는 법
-- 뷰는 select문에 대해서 이름을 붙힌것이라고 생각한다.
select view_name, text
from user_views;
-- 뷰를 이용한 쿼리문을 작성하면 실행이 될때 뷰의 이름이 있는곳에 select문으로 대체된다.

select * from v_emp_salary;


-- 함수의 결과로 뷰를 만들경우 반드시 함수의 결과에 대한 별칭을 주셔야 한다.
create view v_emp_salary
as 
select deptno, sum(sal), avg(sal)
from emp_second
group by deptno;

-- 그룹함수를 가상칼럼으로 갖는 뷰는 DML문을 사용할수없다
insert into v_emp_salary
values(8000, 1000, 300);

drop view v_emp_job;

create or replace view v_emp_job2
as
select empno, ename, deptno, job
from emp_second
where job like 'manager';


create or replace view v_emp_job2
as
select empno, ename, deptno, job
from emp_notable
where job like 'manager';

-- force는 기본 테이블의 유무의 상관없이 무조건 뷰를 만들때 사용한다.
-- noforce 는 반드시 기반이 되는 뷰나 테이블이 있어야 만든다.
-- 위는 오류 
-- 아래는 오류없음
create or replace force view v_emp_job2
as
select empno, ename, deptno, job
from emp_notable
where job like 'manager';
-- emp_notable없이 위의 쿼리 실행시 컴파이 오류와 함께 뷰가 생성되었음을 알린다.

-- 체크 옵션이 없을경우
create or replace view v_emp_job_nochk
as 
select empno, ename, deptno, job
from emp_second
where job like 'manager';

insert into v_emp_job_nochk 
values(9000, '김주현', 30, 'salesman');
-- 뷰에 삽입했지만 뷰에는 삽입이 안되고
select * from v_emp_job_nochk;
-- 테이블에만 삽입이 된다.
select * from emp_second;

-- 이번에는 check option을 추가했다.
create or replace view v_emp_job_chk
as 
select empno, ename, deptno, job
from emp_second
where job like 'manager' with check option;

--이렇게 하고 위와같은 내용을 삽입하면 오류가 난다.
insert into v_emp_job_chk 
values(9000, '김주현', 30, 'salesman');
-- ORA-01402: view WITH CHECK OPTION where-clause violation
-- job이 manager인 것만 삽입해야하기때문 오류가 나는 것이다.
-- job을 manager로 바꾸고 삽입하면 삽입이 된다.
insert into v_emp_job_chk 
values(9000, '김주현', 30, 'manager');
select * from v_emp_job_nochk;

-- 테이블을 만들때 마지막에 with read only 옵션을 주면 삽입/삭제/수정 안된다. 
create or replace view v_emp_job_readonly
as 
select empno, ename, deptno, job
from emp_second 
where job like 'manager' with read only;
-- 아래처럼 삽입하면 read only 오류가 난다.
insert into with read only
values(9000, '김주현', 30, 'manager');
commit;

-- 시퀀스를 만들때에는 몇부터시작 해서 얼마씩 증가하고 어디까지 증가할지가 있어야 한다.
--CREATE SEQUENCE sequence_name 
--                [START WITH n]              ① 시퀀스 번호의 시작값을 지정할 때 사용됩니다. 만일 1부터 시작되는 시퀀스를 생성하려면 START WITH 1이라고 기술하면 됩니다. 
--                [INCREMENT BY n]            ② 연속적인 시퀀스 번호의 증가치를 지정할 때 사용됩니다. 만일 1씩 증가하는 시퀀스를 생성하려면 INCREMENT BY 1이라고 기술하면 됩니다
--                [{MAXVALUE n | NOMAXVALUE}] ③ MAXVALUE 은 시퀀스가 가질 수 있는 최대값을 지정합니다. 만일 NOMAXVALUE를 지정하게 되면 ASCENDING 순서일 경우에는 1027승이고 DESCENDING 순서일 경우에는 -1로 설정됩니다
--                [{MINVALUE n | NOMINVALUE}] ④ MINVALUE 은 시퀀스가 가질수 있는 최소값을 지정합니다. 만일 NOMINVALUE을 지정하게 되면 ASCENDING 순서일 경우에는 1이고 DESCENDING 순서일 경우에는 1026승으로 설정됩니다.
--                [{CYCLE | NOCYCLE}]         ⑤ CYCLE 은 지정된 시퀀스 값이 최대값까지 증가가 완료되게 되면 다시 START WITH 옵션에 지정한 시작 값에서 다시 시퀀스를 시작하도록 합니다. NOCYCLE은 증가가 완료되게 되면 에러를 유발시킵니다. 
--                [{CACHE n | NOCACHE}]       ⑥ CACHE 은 메모리상의 시퀀스 값을 관리하도록 하는 것인데 기본 값은 20입니다. NOCACHE는 원칙적으로 메모리 상에서 시퀀스를 관리하지 않습니다.

-- 시퀀스 생성하기
create sequence sample_seq
increment by 10
start with 10;
-- 데이터베이스에 만들어진 시퀀스 확인하기.
select sequence_name, min_value, max_value,
increment_by, cycle_flag
from user_sequences;

select SAMPLE_SEQ.nextval from dual;
select SAMPLE_SEQ.currval from dual;
-- 새로만들어진 시퀀스를 currval로 조회 하기위해서는 반드시 최초로 nextval을 해서 시퀀스의 값을 만들어주어야 하기 때문이다.
-- 그렇지 않으면 만들어진 시퀀스가 없기 때문에 currval로 조회를 할수가 없다.


-- 시퀀스 생성
create sequence deptno_seq
increment by 10
start with 10;
-- 시퀀스를 이용할 테이블 생성
create table dept_second2
as 
select * from dept where 0=1;
-- 만들어 놓은 시퀀스를 이용해서 삽입하기 deptno을 시퀀스의 값으로 삽입한다.
insert into dept_second2 values(deptno_seq.nextval, 'ACCOUNTING', 'NEW YORK');
select * from dept_second2;

insert into dept_second2 values(deptno_seq.currval, 'ACCOUNTING', 'NEW YORK');
select * from dept_second2;

delete from dept_second2;


-- 시퀀스 변경하기 : 시퀀스 최대값을 50으로 변경
alter sequence deptno_seq
maxvalue 50;
-- 변경된 시퀀스 내용 확인하기
select sequence_name, min_value, max_value,
increment_by, cycle_flag
from user_sequences;
-- 시퀀스 제거하기 
drop sequence deptno_seq;


--인덱스는 검색 속도를 향상시키기 위해서 사용
--인덱스 객체에 대한 정보는 USER_COLUMNS와 USER_IND_COLUMNS 데이터 사전을 통해서 살펴볼 수 있습니다. 
--기본 키나 유일 키는 인덱스가 자동으로 생성됩니다.

-- 현제 만들어져있는 EMP와 DEPT 테이블의 인덱스 확인하기
select index_name ,table_name, column_name 
from user_ind_columns
where table_name in ('EMP', 'DEPT');

select index_name ,table_name, column_name 
from user_ind_columns
where table_name in ('EMP');

create index idx_emp_ename -- 라는 인덱스를 
on emp(ename); -- on 어디에 만들지

select index_name ,table_name, column_name 
from user_ind_columns
where table_name in ('EMP');

-- 인덱스 지우기
drop index idx_emp_ename;

select index_name ,table_name, column_name 
from user_ind_columns
where table_name in ('EMP');

-- 인덱스가 생성된 후에 새로운 행이 추가되거나 삭제될수있고 인덱스로 사용된 칼럼값이 변경될수도 있다.
-- 이럴 경우는 본 테이블에서 추가 삭제 갱신 작업이 일어날때 해당 테이블에 걸린 인덱스 내용도 수정해야 한다.
-- 인덱스를 재생성 할 때 사용하는 기본코드
alter index pk_emp rebuild;

select * from dept_second;
-- 고유인덱스 지정
create unique index idx_dept_dno
on dept_second(deptno);
-- 만들어진 인덱스 확인
select index_name ,table_name, column_name 
from user_ind_columns
where table_name in ('DEPT_SECOND');


insert into dept_second values(50, 'research', 'new york');
select * from dept_second;

-- 속성내용에 중복된 값이 있는 속성에 대해서 고유한 인덱스 만들기를 시도
create unique index idx_dept_loc
on dept_second(loc);
-- 그럼 아래와같이 중복값이 있어서 인덱스를 만들수 없다는 오류가 난다.
--오류 보고 -
--ORA-01452: cannot CREATE UNIQUE INDEX; duplicate keys found
--01452. 00000 -  "cannot CREATE UNIQUE INDEX; duplicate keys found"

create unique index idx_dept_com
on dept_second(dname,loc);


-- 함수의 결과에 대한 인덱스를 만들수도 있다. 하지만 이것은 가상의 컬럼에대한 인덱스가 된다.
create index idx_emp_second_annsal 
on emp_second(sal*12);
-- 만들어진 인덱스 내용을 확인
select index_name, table_name, column_name 
from user_ind_columns
where table_name in ('EMP_SECOND'); 

create sequence emp_seq
start with 1
increment by 1
maxvalue 10000;

drop table emp01;

create table emp01(
    empno number(4) primary key,
    ename varchar(10),
    hiredate date
);

insert into emp01
values(emp_seq.nextval, 'julia', sysdate);

select * from emp01;

create index IDX_EMP01_ENAME
on emp01(ename);


-- 사용권한의 종류
CREATE SESSION ;  -- 데이터베이스에 연결할 수 있는 권한
CREATE TABLE   ;  -- 테이블을 생성할 수 있는 권한
CREATE SEQUENCE ; -- 시퀀스를 생성할 수 있는 권한
CREATE VIEW  ;    -- 뷰를 생성할수 있는 권한





---PL/SQL
-- serveroutput은 기본적으로 off로되어있으며 이것으로 on으로 바꿔준다.
set serveroutput on
-- 변수들을 정의 , 변수명 변수형이온다.
declare 
    v_empno number(10);
    -- %type은 employees의 ename속성과 같은 자료형을 쓰게 해주는 것이다.
    v_ename emp.ename%type;
begin
-- dbms_output패키지 안에있는 put_line프로시져 사용
    dbms_output.put_line('welcome to oracle');
    -- 프로시져에서 대입연산자는 := 이다.
    v_empno := 7788;
    v_ename := 'scott';
    dbms_output.put_line('사원번호 사원이름');
    dbms_output.put_line('--------------');
    -- || 는 자바의 문자열 연산 + 와 같은것이다.
    dbms_output.put_line(v_empno || '  ' || v_ename);
end;
/


set serveroutput on 
declare 
v_empno emp.empno%type;
v_ename emp.ename%type;
begin
dbms_output.put_line('사원번호  사원이름');
dbms_output.put_line('---------------');

select empno, ename into v_empno, v_ename
from emp
where ename = 'scott';

dbms_output.put_line(v_empno || '  ' || v_ename);

end;
/


set serveroutput on 
declare 
v_emp emp%rowtype;
temp number(4) := 1;
annsal number(7,2);

begin
select * into v_emp
from emp
where ename = 'scott';

if (v_emp.comm is null) then
v_emp.comm := 0;
end if;

annsal := v_emp.sal * 12 + v_emp.comm;

dbms_output.put_line('사원번호  사원이름    연봉');
dbms_output.put_line('-----------------------');
dbms_output.put_line('  '|| v_emp.empno || '   ' || v_emp.ename || '   ' || annsal);

end;
/


set serveroutput on
declare 
v_empno emp.empno%type;
v_ename emp.ename%type;
v_deptno dept.deptno%type;
v_dname dept.dname%type;

begin
    select empno, ename, deptno
    into v_empno, v_ename, v_deptno
    from emp
    where ename = 'scott';

    if (v_deptno = 10) then
        v_dname := 'ACCONTING';
    elsif (v_deptno = 20) then
        v_dname := 'RESEARCH';
    elsif (v_deptno = 30) then    
        v_dname := 'SALES';
    elsif (v_deptno = 40) then
        v_dname := 'OPERATIONS';
    end if;
    
    dbms_output.put_line('사원번호  이름  부서명');
    dbms_output.put_line(v_empno || '   ' || v_ename || '   ' || v_dname);
end;
/

set serveroutput on
declare 
    dan number := 2;
    i number := 1;
begin
    loop
        dbms_output.put_line(
            dan || '*' || i || ' = ' || (dan * i));
        i := i+1;
        if i > 9 then
            exit;
        end if;
    end loop;
end;

set serveroutput on
declare 
    dan number := 2;
    i number := 1;
begin
    for i in 1..9 loop
        dbms_output.put_line( dan || '*' || i || ' = ' || (dan * i));
    end loop;
end;
/

set serveroutput on
declare 
    dan number := 2;
    i number := 1;
begin
    while i <= 9 loop
        dbms_output.put_line( dan || '*' || i || ' = ' || (dan * i));
        i := i+1;
    end loop;
end;
/

set serveroutput on
declare 
    dan number := 1;
    i number := 1;
begin
    while dan <= 9  loop
         
        while i <= 9  loop
            dbms_output.put_line( dan || '*' || i || ' = ' || (dan * i));
            i := i+1;
        end loop;
        i := 1;
        dbms_output.put_line(' ');   
        dan := dan + 1;
     end  loop;
end;
/


set serveroutput on 
declare 
    v_dept dept%rowtype;
    cursor c1
    is 
    select * from dept;
begin
    dbms_output.put_line('부서번호  부서명     지역명');
    dbms_output.put_line('-----------------------');
    open c1;
    
    loop 
        fetch c1 into v_dept.deptno, v_dept.dname, v_dept.loc;
        exit when c1 % notfound;
        
        dbms_output.put_line(v_dept.deptno || ' ' || v_dept.dname || '  ' || v_dept.loc);
                
    end loop;
    close c1;
end;
/


set serveroutput on 
declare 
    v_dept dept%rowtype;
    cursor c1
    is 
    select * from dept;
begin
    dbms_output.put_line('부서번호  부서명     지역명');
    dbms_output.put_line('-----------------------');    
    -- for문안에서 cursor를 쓰면 open fetch close가 필요가 없다.
    for v_dept in c1 loop 
        exit when c1%notfound;        
        dbms_output.put_line(v_dept.deptno || ' ' || v_dept.dname || '  ' || v_dept.loc);                
    end loop; 
end;
/
-- PL/SQL로 만들수있는 객체 : 프로시져 함수 트리거
-- 저장프로시져 

drop procedure sp_salary_name;
-- in 은 메개변수값을 받는다를 소리이고
-- out은 어디론가 값을 보낼때 쓴다.
create procedure sp_salary_name(v_ename in emp.ename%type)
is 
v_salary emp.sal%type;
begin
    select sal into v_salary
    from emp
    where ename = v_ename;
    
    dbms_output.put_line(v_ename || '의 급여는 ' || v_salary || '입니다.');
end; 

execute sp_salary_name('scott');


--drop procedure sp_salary_name2;
--create procedure sp_salary_ename2(v_ename in emp.ename%type, v_salary out emp.sal%type)
--is 
--begin 
--    select sal into v_salary
--    from emp
--    where ename = v_ename;
--end;
--/
--
--variable v_salary varchar2(14);
--execute sp_salary_name2('scott',:v_salary);
--print v_salary;
--
--select name, text from user_source;
--where name like('%SP SALARY%');


create or replace function fn_salary_ename(
v_ename in emp.ename%type)
    return number
is
    v_salary number(7,2);
begin
    select sal into v_salary
    from emp
    where ename = v_ename;
    return v_salary;
end;
/

variable v_salary number;
execute : v_salary := fn_salary_ename('scott');
print v_salary;

--1번
create procedure sp_salary
is
v_salary employee.ename%type;
begin 
    select salary into v_salary
    from employee
    where ename='SCOTT';
    dbms_output.put_line('SCOTT의 급여는' || v_salary);
end;


--1번
create or replace procedure sp_salary
is
v_salary emp.ename%type;
begin 
    select sal into v_salary
    from emp
    where ename='scott';
    dbms_output.put_line('SCOTT의 급여는' || v_salary);
end;

execute sp_salary;

--2번  
select name, text from user_source
where name like('%SP_SALARY%');

--3번
show error PROCEDURE @frun01;

--4번
create or replace procedure pro_dept_in(v_deptno IN dept.deptno%type)
is
out_deptno dept.deptno%type;
out_dname dept.dname%type;
out_loc dept.loc%type;
begin 
    select deptno, dname, loc into out_deptno, out_dname, out_loc
    from dept
    where deptno=v_deptno;
    dbms_output.put_line('부서번호 ' || out_deptno);
    dbms_output.put_line('부서이름 ' || out_dname);
    dbms_output.put_line('지역 ' || out_loc);
end;
/

execute pro_dept_in(10);

--5번
DECLARE
    in_deptno dept.deptno%type;
BEGIN
    in_deptno := 10;
    pro_dept_in(in_deptno);
END;



--------------------------------------------
DECLARE
   v_deptno DEPT.DEPTNO%TYPE;
   v_dname DEPT.DNAME%TYPE;
   v_loc DEPT.LOC%TYPE;
BEGIN
   v_deptno := 10;
   pro_dept_in(v_deptno, v_dname, v_loc);
   DBMS_OUTPUT.PUT_LINE('부서번호 : ' || v_deptno);
   DBMS_OUTPUT.PUT_LINE('부서명 : ' || v_dname);
   DBMS_OUTPUT.PUT_LINE('지역 : ' || v_loc);
END;

-- jsp 연동 DB

create table member(
    name varchar2(10),
    userid varchar2(10) primary key,
    pwd varchar2(10),
    email varchar2(20),
    phone char(13),
    admin number(1) default 0 --0:사용자 1:관리자
);


create table member(
    name varchar2(10),
    userid varchar2(10), 
    pwd varchar2(10),
    email varchar2(20),
    phone char(13),
    admin number(1) default 0 
);

insert into member values('이소미', 'somi', '1234', 'gmd@naver.com', '010-2362-5157', 0);    
insert into member values('하상오', 'sang12', '1234', 'ha12@naver.com', '010-5629-8888', 1);    
insert into member values('김윤승', 'light', '1234', 'youn1004@naver.com', '010-9999-8282', 0);   
select * from member;



drop table item;
create table item(
    name  varchar2(20) primary Key,
    price number(8),
    description varchar2(100)
);

select * from item;



--------------------------------------------------------------------
drop table EMPLOYEES;
CREATE TABLE EMPLOYEES(
    id varchar2(10) not null,
    pass varchar2(10) not null,
    name varchar2(24), 
    lev char(1) DEFAULT 'A', -- A : 운영자 B : 일반회원
    enter DATE DEFAULT SYSDATE, --등록일
    gender char(1) DEFAULT '1', -- 1 : 남자 2 : 여자
    phone varchar2(30),
    PRIMARY KEY(id)
);

insert into EMPLOYEES Values ('subin', '1234', '전수빈', 'B', sysdate , '2', '010-9999-9999');
insert into EMPLOYEES Values ('admin', '1234', '정운영', 'A', sysdate , '1', '010-1111-1111');

select * From EMPLOYEES; 
commit;

select id, pass, lev from Employees where id = 'admin';

select pass, lev from Employees where id = 'subin';


create table product(
    code number(5),
    name varchar2(100),
    price number(8),
    pictureurl varchar(50),
    description varchar(1000),
    primary key(code)
);

create sequence product_seq start with 1 increment by 1;

insert into product values(product_seq.nextval, '개념을 콕콕 잡아주는 데이터베이스', 27000, 'db.jpg', '데이터베이스에 관한 모든 것을 쉽고 재미있게 정리한 교재...');
insert into product values(product_seq.nextval, '웹표준을 위한 HTML5', 25000, 'html5.jpg', 'HTML5 가이드북. 홈페이지 제작을 위한 필수 선택HTML기본 문법...');
insert into product values(product_seq.nextval, 'Dynamic Programming book 시리즈-01 오라클 11g + PL/SQL', 25000, 'oracle.jpg', 'Dynamic 실무코칭프로그래밍 Book의 첫번째 책으로', '오라클 11g의 새로운...');
insert into product values(product_seq.nextval, 'Visaul C++ MFC 윈도우 프로그래밍', 26000, 'mfc.jpg', 'Visual C++를 처음 시작하는 독자의 눈 높이에 맞춘 Visual C++...');
insert into product values(product_seq.nextval, 'jQuery and jQuety Mobile : 이해하기 쉽게 플어쓴', 25000, 'jquery.jpg', '소스 하나로 데스크탑과 모바일 까지 HTML5와 함께 사용한다. 초보자들도 ...');
commit;

select * From product;

drop table movie;

create table movie(
    code number(4) primary key,
    Title varchar(20),
    price number(10),
    director varchar(20),
    actor varchar(20),
    poster varchar(100),
    synopsis varchar(3000)    
);

create sequence movie_seq start with 1 increment by 1;

insert into movie values(movie_seq.nextval, '베를린', 10000, '류승완', '하정우', 'movie1.jpg', '거대한 국제적 음모가 숨겨진 운명의 도시');
insert into movie values(movie_seq.nextval, '박수건달', 10000, '조진규', '박신양,엄지원', 'movie2.jpg', '건달로 사느냐 무당으로 사느냐 그것이 문제');
insert into movie values(movie_seq.nextval, '레미제라블', 10000, '톰 후퍼', '휴 잭맨', 'movie3.jpg', '빵 한 조각을 훔친 죄로 19년 감옥살이를 한 장발장');
insert into movie values(movie_seq.nextval, '7번방의선물', 9000, '이환경', '류승룡, 갈소원', 'movie4.jpg', '최악의 흉악범들이 모인 교도소 7번방에 이상한');

commit;
select * from movie order by code desc;

update movie set title = '베발', price = 111122, director = '베발', actor = '베발', poster = '베발', synopsis = '베발' where code = 66;


------------------------------------------------------


create sequence board_seq start with 1 increment by 1;
drop table board;
CREATE TABLE board(
    num Number(5) primary key,
    pass varchar2(30),
    name varchar2(30),
    email varchar2(30),
    title varchar2(50),
    content varchar2(1000),
    readcount Number(4) default 0,
    writedate date default sysdate
);

insert into board(num, name, email, pass, title, content)
values(board_seq.nextval, '성윤정', 'pinksung@nate.com', '1234', '첫방문', '반갑습니다.');

insert into board(num, name, email, pass, title, content)
values(board_seq.nextval, '성윤정', 'pinksung@nate.com', '1234', '김밥', '맛있어요.');

insert into board(num, name, email, pass, title, content)
values(board_seq.nextval, '전수빈', 'raccon@nate.com', '3333', '고등애', '일식입니다.');

insert into board(num, name, email, pass, title, content)
values(board_seq.nextval, '전원지', 'one@nate.com', '1111', '갯골마을', '돼지삼겹살이 맛있습니다.');

select * from board;


select * from board order by num desc
commit;

----------------------------------------------------------
drop table member
--*member 테이블
create table member(
memNum number(20) not null primary key,
memType number(2) not null,
memId varchar2(20) not null,
memPwd varchar2(20) not null,
memName varchar2(20) not null,
user_birth_year number(6) not null,
user_birth_month number(6) not null,
user_birth_day number(6) not null,
memGen  varchar2(20) not null,
memEmail varchar2(200) not null,
memPhone  varchar2(20) not null,
memAdd_1  varchar2(50) not null,
memAdd_2  varchar2(50) not null,
memAdd_3  varchar2(50) not null);
select * from member;

--*member number 시퀀스 소스

create SEQUENCE id_seq
start with 1
INCREMENT by 1
MAXVALUE 100000;

insert into member VALUES(id_seq.nextval,1,
'gptjd',
'1234',
'강혜성',1994,04,24,'남자','gptjd@naver.com',
'010-4640-1234','16521','경기도 수원시','경수대로 211번길');

select * from mem_exex order by memnum;
select * from Product order by proid;
select * from Product order by resid;
--*상품테이블
create table Product(
proid number(5) not null primary key,
proType varchar2(100) not null,
proName varchar2(200) not null,
proPrice number(20) not null);

--*상품 시퀀스 소스

create SEQUENCE product_seq
start with 1
INCREMENT by 1
MAXVALUE 100000;


--*예약테이블
create table Reserve(
resid number(20) not null primary key,
memid varchar2(20) references mem_exex(memId) not null,
proid number(5) references product(proid) not null,
proname varchar2(20) not null,
resnum number(2) not null,
resCharge number(20) not null,
resPay number(1) not null);

--*예약 시퀀스 소스
create SEQUENCE Reserve_seq
start with 1
INCREMENT by 1
MAXVALUE 100000;

--*세탁 소스
insert into product values(product_seq.nextval, '세탁-물빨래','세탁30L',10000);
insert into product values(product_seq.nextval, '세탁-셔츠','일반셔츠',2000);

--*이불
insert into product values(product_seq.nextval, '세탁-이불','이불커버,홑이불',9000);
insert into product values(product_seq.nextval, '세탁-이불','일반이불,극세사패드',12000);
insert into product values(product_seq.nextval, '세탁-이불','극세사 이불,일반 토퍼',18000);
insert into product values(product_seq.nextval, '세탁-이불','구스이불,양모이불,실크이불',23000);
insert into product values(product_seq.nextval, '세탁-이불','구스토퍼',30000);
insert into product values(product_seq.nextval, '세탁-이불','구스베개',12000);
insert into product values(product_seq.nextval, '세탁-이불','아동이불,무릎담요',7000);

--*잡화
insert into product values(product_seq.nextval, '세탁-잡화','커튼',15000);
insert into product values(product_seq.nextval, '세탁-잡화','암막',25000);
insert into product values(product_seq.nextval, '세탁-잡화','러그,카펫',18000);
insert into product values(product_seq.nextval, '세탁-잡화','베개커버',3500);
insert into product values(product_seq.nextval, '세탁-잡화','발매트',5000);
insert into product values(product_seq.nextval, '세탁-잡화','일반모자',4000);
insert into product values(product_seq.nextval, '세탁-잡화','캡모자',6000);
insert into product values(product_seq.nextval, '세탁-잡화','스카프,목도리',4000);
insert into product values(product_seq.nextval, '세탁-잡화','장갑',4000);
insert into product values(product_seq.nextval, '세탁-잡화','숄',8000);
insert into product values(product_seq.nextval, '세탁-잡화','넥타이',2500);
insert into product values(product_seq.nextval, '세탁-잡화','수영복',6000);
insert into product values(product_seq.nextval, '세탁-잡화','스키복(상의)',15000);
insert into product values(product_seq.nextval, '세탁-잡화','스키복(하의)',10000);
insert into product values(product_seq.nextval, '세탁-잡화','에코백',3500);
insert into product values(product_seq.nextval, '세탁-잡화','인형',7000);
insert into product values(product_seq.nextval, '세탁-잡화','모직,양모양말',3000);
insert into product values(product_seq.nextval, '세탁-잡화','일반운동화',6500);
insert into product values(product_seq.nextval, '세탁-잡화','세무,가죽운동화',8500);
insert into product values(product_seq.nextval, '세탁-잡화','로퍼',11000);
insert into product values(product_seq.nextval, '세탁-잡화','농구화,축구화',9000);
insert into product values(product_seq.nextval, '세탁-잡화','골프화,등산화',11000);
insert into product values(product_seq.nextval, '세탁-잡화','아동신발',5500);
insert into product values(product_seq.nextval, '세탁-잡화','명품운동화',20000);


--*드라이크리닝 소스
insert into product values(product_seq.nextval, '드라이크리닝-정장','상의',5000);
insert into product values(product_seq.nextval, '드라이크리닝-정장','하의',4000);
insert into product values(product_seq.nextval, '드라이크리닝-정장','조끼',3000);
insert into product values(product_seq.nextval, '드라이크리닝-정장','원피스',6000);

insert into product values(product_seq.nextval, '드라이크리닝-상의','티셔츠',4000);
insert into product values(product_seq.nextval, '드라이크리닝-상의','블라우스',4500);
insert into product values(product_seq.nextval, '드라이크리닝-상의','후드티,맨투맨',4500);
insert into product values(product_seq.nextval, '드라이크리닝-상의','니트,스웨터',5000);
insert into product values(product_seq.nextval, '드라이크리닝-상의','가디건',6000);
insert into product values(product_seq.nextval, '드라이크리닝-상의','롱가디건',7500);

insert into product values(product_seq.nextval, '드라이크리닝-하의','바지',4500);
insert into product values(product_seq.nextval, '드라이크리닝-하의','스커트',4500);
insert into product values(product_seq.nextval, '드라이크리닝-하의','점프수트',9000);
insert into product values(product_seq.nextval, '드라이크리닝-하의','인조가죽/세무',8500);

insert into product values(product_seq.nextval, '드라이크리닝-아우터','점퍼',6500);
insert into product values(product_seq.nextval, '드라이크리닝-아우터','재킷',7500);
insert into product values(product_seq.nextval, '드라이크리닝-아우터','패딩',10000);
insert into product values(product_seq.nextval, '드라이크리닝-아우터','다운패딩',15000);
insert into product values(product_seq.nextval, '드라이크리닝-아우터','롱패딩',18000);
insert into product values(product_seq.nextval, '드라이크리닝-아우터','프리미엄패딩',25000);
insert into product values(product_seq.nextval, '드라이크리닝-아우터','패딩조끼',7000);

drop table Board;

Create Table Board(
    bId Number(4) primary key,
    bName varchar2(20),
    bTitle varchar2(100),
    bContent varchar2(300),
    bDate Date Default SYSDATE,
    bHit Number(4) default 0,
    bGroup Number(4),
    bStep number(4),
    bIndent Number(4)
);

select * from member order by memnum;
select * from Product order by proid;
select * from Reserve order by resid;

delete member where memnum = 6;
commit;

----------------------------------------------------------
drop table mvc_board;

create table mvc_board(
    bId Number(4) primary key,
    bName varchar2(20),
    bTitle varchar2(100),
    bContent varchar2(300),
    bDate Date Default SYSDATE,
    bHit Number(4) default 0,
    bGroup Number(4),
    bStep number(4),
    bIndent Number(4)
);
drop sequence mvc_board_seq;
create sequence mvc_board_seq;

insert into mvc_board(bId, bName, bTitle, bContent, bHit, bGroup, bStep, bIndent)
values (mvc_board_seq.nextval, 'abcd', 'is title', 'is content', 0, mvc_board_seq.currval, 0, 0);

select * from mvc_board;
insert into mvc_board(bid,bname,btitle,bcontent,bgroup,bstep,bindent)
(select mvc_board_seq.nextval,bname,btitle,bcontent,mvc_board_seq.currval,0,0 from mvc_board);
commit;

commit;

-----------------------------------------------------------------------
create table mvc_board_pass(
    bId Number(4) primary key,
    bPass varChar(30),
    bName varchar2(20),
    bTitle varchar2(100),
    bContent varchar2(300),
    bDate Date Default SYSDATE,
    bHit Number(4) default 0,
    bGroup Number(4),
    bStep number(4),
    bIndent Number(4)
);

drop table mvc_board_pass;
drop sequence mvc_board_pass_seq;
create sequence mvc_board_pass_seq;
commit;
insert into mvc_board_pass(bId, bPass, bName, bTitle, bContent, bHit, bGroup, bStep, bIndent)
values (mvc_board_pass_seq.nextval,'zxc123', 'abcd', 'is title', 'is content', 0, mvc_board_pass_seq.currval, 0, 0);

insert into mvc_board_pass(bId, bPass, bName, bTitle, bContent, bHit, bGroup, bStep, bIndent)
values (mvc_board_pass_seq.nextval,'1234', 'dddd', 'is asdad', 'is content', 0, mvc_board_pass_seq.currval, 0, 0);

insert into mvc_board_pass(bId, bPass, bName, bTitle, bContent, bHit, bGroup, bStep, bIndent)
values (mvc_board_pass_seq.nextval,'1234', 'cccc', 'is eeee', 'is content', 0, mvc_board_pass_seq.currval, 0, 0);
select * from  mvc_board_pass;
commit;

----20200709 페이징--------위와같은 테이블 사용----
--- 원 하는 부분의 내용 데이터 긁어오기
select * from
(select rownum m, sub.* from 
(select bId, bPass, bName, bTitle, bContent, bDate, bHit, bGroup, bStep, bIndent
from mvc_board_pass
order by bGroup desc, bStep asc)sub
where rownum <= 2*10 
order by bGroup desc, bStep asc)
where m>=(2-1)*10+1;

------------------------------------------------------------------
select * from 
(select rownum m, bId, bPass, bName, bTitle, bContent, bDate, bHit, bGroup, bStep, bIndent
from (select bId, bPass, bName, bTitle, bContent, bDate, bHit, bGroup, bStep, bIndent
from mvc_board_pass
order by bGroup desc, bStep asc)sub
where rownum <= 2*10 
order by bGroup desc, bStep asc)
where m>=(2-1)*10+1;
--------------------------------------------------
select * from (select rownum m, bId, bPass, bName, bTitle, bContent, bDate, bHit, bGroup, bStep, bIndent from (select bId, bPass, bName, bTitle, bContent,  bDate, bHit, bGroup, bStep, bIndent from mvc_board_pass order by bGroup desc, bStep asc)sub where rownum <= 1*10  order by bGroup desc, bStep asc) where m>=(1-1)*10+1;

-----------------------------------------------------------------------------------------------
desc mvc_board
select * from mvc_board_pass;
insert into mvc_board_pass(bid,bpass,bname,btitle,bcontent,bgroup,bstep,bindent)
(select mvc_board_pass_seq.nextval,bpass,bname,btitle,bcontent,mvc_board_pass_seq.currval,0,0 from mvc_board_pass);
commit;
--2페이지 한페이지 데이터 개수 5
--2와 5는 사용자에 의해서 변경될수 있다
--변경가능하도록 쿼리를 변경해 보자. ex)3 10


select * from (select rownum m, bId, bPass, bName, bTitle, bContent, bDate, bHit, bGroup, bStep, bIndent from 
(select bId, bPass, bName, bTitle, bContent,  bDate, bHit, bGroup, bStep, bIndent from mvc_board_pass order by bGroup desc, bStep asc)
sub where rownum <= 1*10  order by bGroup desc, bStep asc) 
where m>=(1-1)*10+1 select count(bId) bCount from mvc_board_pass;

select rownum,bid,bname,btitle,bcontent,bgroup,bstep,bindent
from mvc_board 
where rownum between 1 and 10
order by bgroup desc, bstep asc;

select * from
(select rownum m,bid,bname,btitle,bcontent,bgroup,bstep,bindent
from mvc_board 
where rownum <= 2*5   -- 10 --보여줄 페이지의 마지박 데이터
order by bgroup desc, bstep asc)
where m>=(3-1)*5+1;   --11;--시작 데이터

delete from mvc_board where bId >=1000;






----------------------검색-----------------------------------

select * from (
select rownum m, bId, bPass, bName, bTitle, bContent, bDate, bHit, bGroup, bStep, bIndent 
from (
select bId, bPass, bName, bTitle, bContent,  bDate, bHit, bGroup, bStep, bIndent 
from mvc_board_pass order by bGroup desc, bStep asc)sub 
where rownum <= 2*5 and BNAME like '%%' order by bGroup desc, bStep asc) 
where m>=(3-1)*5+1;

select * from (select rownum m, bId, bPass, bName, bTitle, bContent, bDate, bHit, bGroup, bStep, bIndent from (select bId, bPass, bName, bTitle, bContent,  bDate, bHit, bGroup, bStep, bIndent from mvc_board_pass order by bGroup desc, bStep asc)sub where rownum <= 1*10 and bTitle like '%%' order by bGroup desc, bStep asc) where m>=(1-1)*10+1

select * from mvc_board;
select * from(select rownum m, sub.* from (select * from mvc_board order by bGroup desc,bStep asc) sub where rownum <= 1*10 and bTitle like '%a%') where m>=(1-1)*10+1;

----------------------------------그림추가-----------------------------------------------------------------------------------
create table mvc_board_poster(
    bId Number(4) primary key,
    bName varchar2(20),
    bTitle varchar2(100),
    bContent varchar2(300),
    bDate Date Default SYSDATE,
    bHit Number(4) default 0,
    bGroup Number(4),
    bStep number(4),
    bIndent Number(4),
    bPoster varchar2(100) default '없음'
);


insert into mvc_board_poster(bId, bName, bTitle, bContent, bHit, bGroup, bStep, bIndent, bPoster)
values (mvc_board_seq.nextval, 'abcd', 'is title', 'is content', 0, mvc_board_seq.currval, 0, 0, '개근육_shark34.jpg');

select * from mvc_board_poster;
insert into mvc_board_poster(bid,bname,btitle,bcontent,bgroup,bstep,bindent,bPoster)
(select mvc_board_seq.nextval,bname,btitle,bcontent,mvc_board_seq.currval,0,0,bPoster from mvc_board_poster);
commit;

select * from(select rownum m, sub.* from (select * from mvc_board_poster order by bGroup desc,bStep asc) sub where rownum <= 1*10 and bTitle like '%%') where m>=(1-1)*10+1

-----------------------------------------------------------------------------------------------------
drop table Notice_board;

create table Notice_board(
    bId Number(4) primary key,    
    bName varchar2(20),
    bTitle varchar2(100) not null,
    bContent varchar2(300),
    bDate Date Default SYSDATE,
    bHit Number(4) default 0,
    bGroup Number(4),
    bStep number(4),
    bIndent Number(4),
    memId varchar2(20),
    memType number(2)
);
drop sequence Notice_board_seq;
create sequence Notice_board_seq start with 1 Increment by 1;

insert into Notice_board(bId, bName, bTitle, bContent, bHit, bGroup, bStep, bIndent, memId, memType)
values (Notice_board_seq.nextval, 'abcd', 'is title', 'is content', 0, Notice_board_seq.currval, 0, 0, 'gptjd', 2);

select * from Notice_board;
insert into Notice_board(bId, bName, bTitle, bContent, bHit, bGroup, bStep, bIndent, memId, memType)
(select mvc_board_seq.nextval,bname,btitle,bcontent,bHit,Notice_board_seq.currval,0,0,memId, memType from Notice_board);
commit;

--------------------공지사항 + 파일 받기-----------------------------------------------------------------------------------
drop table  Notice_board_file;
create table Notice_board_file(
    bId Number(10) primary key,    
    bName varchar2(20),
    bTitle varchar2(100) not null,
    bContent varchar2(300),
    bDate Date Default SYSDATE,
    bHit Number(4) default 0,
    bGroup Number(10),
    bStep number(10),
    bIndent Number(10),
    memId varchar2(20),
    memType number(2),
    bFile varchar2(500)
);

drop sequence Notice_board_file_seq;
create sequence Notice_board_file_seq start with 1 Increment by 1;

insert into Notice_board_file(bId, bName, bTitle, bContent, bHit, bGroup, bStep, bIndent, memId, memType, bFile)
values (Notice_board_file_seq.nextval, 'abcd', 'is title', 'is content', 0, Notice_board_file_seq.currval, 0, 0, 'gptjd', 2,'D:\JSP\work\20200716EazyandClean\WebContent\images\개쪼갬_rlagksrl801.jpg');

select * from Notice_board_file order by bId;

insert into Notice_board_file(bId, bName, bTitle, bContent, bHit, bGroup, bStep, bIndent, memId, memType, bFile)
(select mvc_board_file_seq.nextval,bname,btitle,bcontent,Notice_board_file_seq.currval,bHit,0,0,memId, memType, bFile from Notice_board_file);
commit;


insert into Notice_board_file(bId,bName,bTitle,bContent,bGroup,bStep,bIndent,bFile) 
values (Notice_board_file_seq.nextval,'pkjhj9746','사진넣기','사진',Notice_board_file_seq.currval,0,0,null)



insert into Notice_board_file(bId,bName,bTitle,bContent,bGroup,bStep,bIndent,bFile)
values (Notice_board_file_seq.nextval,'null','null','null',Notice_board_file_seq.currval,0,0,'개근육_shark34.jpg')

select * from Notice_board_file order by bId;

--공지사항 답글 기능 
-- 7-6답글보드
drop table Notice_board_comment; 
CREATE TABLE Notice_board_comment 
(
  NOTICE_COMMENT_NUM NUMBER NOT NULL,
  NOTICE_COMMENT_BOARD NUMBER NOT NULL,
  NOTICE_COMMENT_ID VARCHAR2(15),
  NOTICE_COMMENT_DATE DATE default sysdate,
  NOTICE_COMMENT_CONTENT VARCHAR2(1000) NOT NULL,
  CONSTRAINT PK_comment PRIMARY KEY(NOTICE_COMMENT_NUM),
  CONSTRAINT FK_comment FOREIGN KEY(NOTICE_COMMENT_BOARD) REFERENCES Notice_board_file(bId)
);
select * from Notice_board_comment;
create sequence boardComment_seq start with 1 increment by 1;

insert into Notice_board_comment (NOTICE_COMMENT_NUM, NOTICE_COMMENT_BOARD, NOTICE_COMMENT_ID,  NOTICE_COMMENT_CONTENT)
values(boardComment_seq.nextval, 21, 'pkjhj9746', '답글달기가 과연 될까/?');

select * from Notice_board_comment where NOTICE_COMMENT_BOARD=21 order by NOTICE_COMMENT_NUM desc;
insert into Notice_board_comment (NOTICE_COMMENT_NUM, NOTICE_COMMENT_BOARD, NOTICE_COMMENT_ID,  NOTICE_COMMENT_CONTENT) 
values(boardComment_seq.nextval, 21, '', '????§???????')




insert into Notice_board_comment (NOTICE_COMMENT_NUM, NOTICE_COMMENT_BOARD, NOTICE_COMMENT_ID, NOTICE_COMMENT_CONTENT)
(select boardComment_seq.nextval, NOTICE_COMMENT_BOARD, NOTICE_COMMENT_ID, NOTICE_COMMENT_CONTENT from Notice_board_comment);




insert into Notice_board_file(bId, bName, bTitle, bContent, bHit, bGroup, bStep, bIndent, memId, memType, bFile)
(select mvc_board_file_seq.nextval,bname,btitle,bcontent,Notice_board_file_seq.currval,bHit,0,0,memId, memType, bFile 
from Notice_board_file);
commit;

select * from 
(select rownum m,NOTICE_COMMENT_NUM, NOTICE_COMMENT_BOARD, NOTICE_COMMENT_ID, NOTICE_COMMENT_DATE,NOTICE_COMMENT_CONTENT  
from (select NOTICE_COMMENT_NUM, NOTICE_COMMENT_BOARD, NOTICE_COMMENT_ID, NOTICE_COMMENT_DATE,NOTICE_COMMENT_CONTENT   
from Notice_board_comment order by NOTICE_COMMENT_BOARD desc)sub  
where rownum <= 1*10  order by NOTICE_COMMENT_BOARD desc)  where m>=(1-1)*10+1


select * from 
(select rownum m,NOTICE_COMMENT_NUM, NOTICE_COMMENT_BOARD, NOTICE_COMMENT_ID, NOTICE_COMMENT_DATE,NOTICE_COMMENT_CONTENT  
from (select NOTICE_COMMENT_NUM, NOTICE_COMMENT_BOARD, NOTICE_COMMENT_ID, NOTICE_COMMENT_DATE,NOTICE_COMMENT_CONTENT   
from Notice_board_comment where NOTICE_COMMENT_BOARD=21 order by NOTICE_COMMENT_NUM desc)sub  
where rownum <= 1*20  order by NOTICE_COMMENT_BOARD)  where m>=(1-1)*20+1

select * from Notice_board_comment order by NOTICE_COMMENT_NUM desc;

select * from 
(select rownum m,NOTICE_COMMENT_NUM, NOTICE_COMMENT_BOARD, NOTICE_COMMENT_ID, NOTICE_COMMENT_DATE,NOTICE_COMMENT_CONTENT  
from (select NOTICE_COMMENT_NUM, NOTICE_COMMENT_BOARD, NOTICE_COMMENT_ID, NOTICE_COMMENT_DATE,NOTICE_COMMENT_CONTENT   
from Notice_board_comment  where NOTICE_COMMENT_BOARD=21 order by NOTICE_COMMENT_BOARD desc)sub  
where rownum <= 7*5  order by NOTICE_COMMENT_BOARD) where m>=(7-1)*5+1;

--------------------------------------------------------------------------------

update Notice_board_file set bHit=bHit+1 where bId=${dto.bId}
-------------답글 들여쓰기 ----------------------------------------------------------------------------------------------------------
drop table  Notice_board_comment_id_page; 

CREATE TABLE Notice_board_comment_id_page 
(
  NOTICE_COMMENT_NUM NUMBER NOT NULL,
  NOTICE_COMMENT_BOARD NUMBER NOT NULL,
  NOTICE_COMMENT_ID VARCHAR2(15),
  NOTICE_COMMENT_DATE DATE default sysdate,
  NOTICE_COMMENT_CONTENT VARCHAR2(1000) NOT NULL,
  NOTICE_COMMENT_INDENT NUMBER default 0,
  NOTICE_COMMENT_GROUPID NUMBER default 0,
  NOTICE_COMMENT_STEP NUMBER NOT NULL,
  CONSTRAINT PK_comment2 PRIMARY KEY(NOTICE_COMMENT_NUM),
  CONSTRAINT FK_comment2 FOREIGN KEY(NOTICE_COMMENT_BOARD) REFERENCES Notice_board_file(bId)
);

drop sequence conment_group_seq;
drop sequence  Comment_num_seq;
drop sequence conment_step_seq;
create sequence conment_group_seq start with 1 increment by 1;
select * from NOTICE_BOARD_COMMENT_ID_PAGE;
create sequence Comment_num_seq start with 1 increment by 1;
create sequence conment_step_seq start with 1 increment by 1;

insert into Notice_board_comment_id_page (
NOTICE_COMMENT_NUM,
NOTICE_COMMENT_BOARD,
NOTICE_COMMENT_ID,
NOTICE_COMMENT_CONTENT,
NOTICE_COMMENT_INDENT,
NOTICE_COMMENT_GROUPID, 
NOTICE_COMMENT_STEP
) values (Comment_num_seq.nextval, 21, 'ppp', 'this is comment', 0,Comment_num_seq.currval, conment_step_seq.nextval);



select * from Notice_board_comment_id_page;

select * from 
(select rownum m,NOTICE_COMMENT_NUM, NOTICE_COMMENT_BOARD, NOTICE_COMMENT_ID, NOTICE_COMMENT_DATE,NOTICE_COMMENT_CONTENT,NOTICE_COMMENT_INDENT,NOTICE_COMMENT_GROUPID,NOTICE_COMMENT_STEP  
from (select NOTICE_COMMENT_NUM, NOTICE_COMMENT_BOARD, NOTICE_COMMENT_ID, NOTICE_COMMENT_DATE,NOTICE_COMMENT_CONTENT,NOTICE_COMMENT_INDENT,NOTICE_COMMENT_GROUPID,NOTICE_COMMENT_STEP   
from Notice_board_comment_id_page where NOTICE_COMMENT_BOARD=21 order by NOTICE_COMMENT_GROUPID desc, NOTICE_COMMENT_STEP asc)sub  
where rownum <= 1*20  order by NOTICE_COMMENT_BOARD)  where m>=(1-1)*20+1

insert into Notice_board_comment_id_page(NOTICE_COMMENT_NUM,
NOTICE_COMMENT_BOARD,
NOTICE_COMMENT_ID,
NOTICE_COMMENT_CONTENT,
NOTICE_COMMENT_INDENT,
NOTICE_COMMENT_GROUPID, 
NOTICE_COMMENT_STEP)
(select Comment_num_seq.nextval,
NOTICE_COMMENT_BOARD,
NOTICE_COMMENT_ID,
NOTICE_COMMENT_CONTENT,
NOTICE_COMMENT_INDENT,
Comment_num_seq.currval, 
NOTICE_COMMENT_STEP
from Notice_board_comment_id_page);

select * from 
(select rownum m,NOTICE_COMMENT_NUM, NOTICE_COMMENT_BOARD, NOTICE_COMMENT_ID, NOTICE_COMMENT_DATE,NOTICE_COMMENT_CONTENT,NOTICE_COMMENT_INDENT,NOTICE_COMMENT_GROUPID,NOTICE_COMMENT_STEP  
from (select NOTICE_COMMENT_NUM, NOTICE_COMMENT_BOARD, NOTICE_COMMENT_ID, NOTICE_COMMENT_DATE,NOTICE_COMMENT_CONTENT,NOTICE_COMMENT_INDENT,NOTICE_COMMENT_GROUPID,NOTICE_COMMENT_STEP   
from Notice_board_comment_id_page where NOTICE_COMMENT_BOARD=21 order by NOTICE_COMMENT_GROUPID desc, NOTICE_COMMENT_STEP asc)sub  
where rownum <= 1*20  order by NOTICE_COMMENT_BOARD)  where m>=(1-1)*20+1;
--------------------------------------------------------------------

--20200730금
create table board(
mId number(4) primary key,
mWriter varchar2(100),
mContent varchar2(300)
);
create sequence board_seq;

select * From board;


--------------------------------------------------------------------------------------

--20200803 월
--1.데이터베이스 작성

drop table ticket;
drop table card;

create table ticket(
consumerid varchar(100),
countnum number(10),
constraint contnum_ck check(countnum<5) 
);
select * from ticket;


create table card(
consumerid varchar(100),
amount number(10)
);
select * from ticket;
select * from card;
Handles requests for the application home page.












